# 今日のプロセスマネージャごっこまとめ

---

## ✅ 実践した内容（詳細版）

### 1. デーモン化のステップとその意味

* `os.fork()`：親プロセスを終了させて子プロセスに移行。これにより元の端末から独立を始める。
* `os.setsid()`：新しいセッションを作成。セッションリーダーとして現在の端末（TTY）・プロセスグループから切り離される。
* 2回目の `os.fork()`：セッションリーダーの状態を放棄。再び fork することで、端末を再取得できない状態にする。
* `os.dup2()` によって標準入力・出力・エラーをすべて `/dev/null` に切り替え、端末とのI/Oを完全遮断。
* `os.chdir('/')`：作業ディレクトリをルートに変更。デーモンが削除されたディレクトリに居座らないようにする。
* `os.umask(0)`：ファイル作成時のパーミッションマスクをクリアし、環境依存を排除。

### 2. デーモンが"生きてる"のを確認する方法

* `ps -ef | grep my_daemon`：プロセス一覧から存在を確認。
* `htop`：対話的に PID や状態を可視化。
* `tail -f /tmp/my_daemon_heartbeat.log`：1秒ごとに heartbeat を吐くことで、活動中であることを明示的に表示。

### 3. `&`（バックグラウンド実行）とデーモンの違い

| 実行方法  | 親プロセス            | ターミナル閉じたら    | 出力先              | プロセスの性質       |
| ----- | ---------------- | ------------ | ---------------- | ------------- |
| `&`   | シェル（bash）        | 死ぬ（SIGHUP受信） | ターミナル            | 親の監視下にある子プロセス |
| デーモン化 | 孤立（init/systemd） | 生き続ける        | /dev/null or log | 完全に独立した常駐プロセス |

* `&` はシェルの機能。親プロセスがシェルなので、端末と切れず、閉じると死ぬ。
* デーモンはプロセス自身が孤立を選択するので、どこにもぶら下がっておらず OS 上で独立して動き続ける。

### 4. セッションとは何か？

* セッション：端末とそれに紐づくプロセスの論理的なまとまり。
* 通常はログインシェルがセッションリーダー。
* `setsid()` を呼ぶことで、新しいセッションを作成し、

  * 端末との関連
  * プロセスグループとの紐づき
  * 親プロセスの関係
    を断ち切る。
* Macでは `ps -o pid,sid,pgid,tty,command -p <PID>` でセッションIDを確認可能。

  * `sid` がセッションID
  * `tty` が `-` なら端末非接続（= デーモン的）

---

## ✅ 今日の技術的ハイライト

* `setsid()` の役割は「プロセスをセッションから切り離すこと」。これがターミナルからの真の独立を意味する。
* デーモン化では「親・セッション・端末・I/O」のすべてを切り離すのが流儀。
* `&` は見た目上のバックグラウンド実行に過ぎず、プロセス自体はターミナルと紐づいたまま。
* `tail -f` によるログ監視で、ユーザーが"生きてる感"を視覚的に実感できた。

---

これらの仕組みを理解・体験することで、UNIX哲学に基づいたプロセス管理・常駐化の実践的理解が深まった。
""
